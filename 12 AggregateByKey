// aggregateByKey used combiners which leads to better performance
// aggregateByKey mostly used to calculate an intermediate values like average
// same problem statement as reduceByKey can be done in one operation 
val orderItems = sc.textFile("/user/cloudera/retail_db/order_items")
val orderItemsMap = orderItems.map(orderItem => (orderItem.split(",")(1).toInt, orderItem.split(",")(4).toFloat))

// The input is in a form of (order_id, order_item_subtotal)
// Total revenue and max revenue generated by each order
val revenueAndMaxRevenuePerOrderId = orderItemsMap.
	aggregateByKey((0.0f, 0.0f))(
		(inter, subtotal) => (inter._1 + subtotal, if(subtotal > inter._2) subtotal else inter._2),
		(total, inter) => (total._1 + inter._1, if(total._2 > inter._2) total._2 else inter._2)
	)

// output //(order_id, (order_revenue, max_order_item_subtotal))
revenueAndMaxRevenuePerOrderId.sortByKey().take(10).foreach(println)
(1,(299.98,299.98))                                                             
(2,(579.98,250.0))
(4,(699.85004,299.95))
(5,(1129.8601,299.98))


